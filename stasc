#!/usr/bin/ruby
require "optparse"
require "stringio"
require "xml/libxml"
require "set"

XML.default_line_numbers=true
XML::Error.reset_handler

# tags to be empty
$empty_tags = [
	"area",
	"base",
	"basefont",
	"br",
	"col",
	"hr",
	"img",
	"input",
	"isindex",
	"link",
	"meta",
	"param",
]

$ns = "http://tshibata.github.io/2013/stasc"

class Walker
	def term(graft, var, node, getter) # for attribute and property
		name = node.attributes["name"]
		order = node.attributes["order"]
		children = node.children.delete_if{|n| (n.text? and n.content.strip.length == 0)}
		if name
			if children.size != 0
				raise "Error: named (monolithic) #{node.name} must be empty"
			end
			if @names.include?(name)
				raise "Error: #{name} is defined twice"
			end
			@names.add(name)
			@proc.puts "\tObject.defineProperty(#{graft}, '#{name}',{"
			@proc.puts "\t\tset:function(v){#{var}.#{yield 'v'};},"
			@proc.puts "\t\tget:function(){return #{var}.#{getter};}"
			@proc.puts "\t});"
			if order
				i = order.to_i
				if @args.include?(i)
					raise "Error: argument #{i} is defined twice"
				end
				@args.add(i)
				@proc.puts "\tif(#{i}<arguments.length){"
				@proc.puts "\t\t#{graft}.#{name}=arguments[#{i}];"
				@proc.puts "\t}"
			end
		else
			if order
				raise "Error: no order of nameless (composite) #{node.name}"
			end
			if children.size != 1
				raise "Error: #{node.name} can contain only one format"
			end
			if children[0].namespaces.namespace.href != $ns or children[0].name != "format"
				raise "Error: #{node.name} can contain only one format"
			end
			format = children[0]
			list = [XML::Node.new_text("")]
			format.each do |n|
				if n.text? and list[-1].text?
					list[-1] = XML::Node.new_text("#{list[-1].content}#{n.content}")
				else
					list.push(n)
				end
			end
			composition = list.map{|n|
				if n.text?
					text = n.content;
					text.gsub!(/\\/) {"\\\\"};
					text.gsub!(/'/) {"\\'"};
					"'#{text}'"
				elsif n.namespaces.namespace.href == $ns and n.name == "item"
					"m#{n.attributes['name']}"
				else
					raise "Error: format can contain only texts and items"
				end
			}.join("+")
			format.each_element do |item|
				name = item.attributes["name"]
				order = item.attributes["order"]
				if item.children.size != 1
					raise "Error: item can contain only text"
				end
				if not item.children[0].text?
					raise "Error: item can contain only text"
				end
				@proc.puts "\tvar m#{name}='#{item.content}';"
				if order
					i = order.to_i
					if @args.include?(i)
						raise "Error: argument #{i} is defined twice"
					end
					@args.add(i)
					@proc.puts "\tif(#{i}<arguments.length){"
					@proc.puts "\t\tm#{name}=arguments[#{i}];"
					@proc.puts "\t}"
				end
				@names.add(name)
				@proc.puts "\tObject.defineProperty(#{graft}, '#{name}',{"
				@proc.puts "\t\tset:function(v){m#{name}=v;#{var}.#{yield composition};},"
				@proc.puts "\t\tget:function(){return m#{name};}"
				@proc.puts "\t});"
			end
			@proc.puts "\t#{var}.#{yield composition};"
		end
	end

	def walk(graft, node)
		case node.node_type
		when LibXML::XML::Node::TEXT_NODE
			text = node.content.strip
			text.gsub!(/\s+/," ");
			text.gsub!(/\\/) {"\\\\"};
			text.gsub!(/'/) {"\\'"};
			if text.empty? # FIXME: option
				return nil
			else
				return "document.createTextNode('#{text}')"
			end
		when LibXML::XML::Node::ELEMENT_NODE
			var = "n#{@last_var}"
			@last_var = @last_var + 1
			if not graft
				graft = var;
			end
			nodeNS = node.namespaces.namespace
			if nodeNS
				@proc.puts "\tvar #{var}=document.createElementNS('#{nodeNS.href}','#{node.name}');"
			else
				@proc.puts "\tvar #{var}=document.createElement('#{node.name}');"
			end
			node.attributes.each do |attribute|
				attrNS = attribute.namespaces.namespace
				if attrNS
					@proc.puts "\t#{var}.setAttributeNS('#{attrNS.href}','#{attribute.name}','#{attribute.value}');"
				else
					@proc.puts "\t#{var}.setAttribute('#{attribute.name}','#{attribute.value}');"
				end
			end
			node.each do |child|
				childNS = child.namespaces.namespace
				if childNS && childNS.href == $ns
					if child.name == "plug"
						jsdom = nil
						child.each_element do |element|
							if jsdom != nil
								raise "Error: more than one element in a plug at #{node.line_num}"
							end
							jsdom = walk(nil, element)
						end
						name = child.attributes["name"]
						order = child.attributes["order"]
						if @names.include?(name)
							raise "Error: #{name} is defined twice"
						end
						@names.add(name)
						@proc.puts "\tObject.defineProperty(#{graft},'#{name}',{"
						@proc.puts "\t\tset:function(v){#{var}.replaceChild(v,#{jsdom});#{jsdom}=v;},"
						@proc.puts "\t\tget:function(){return #{jsdom};}"
						@proc.puts "\t});"
						if jsdom
							if $empty_tags.include?(node.name.downcase)
								puts "Warning: #{node.name} should be empty (line #{node.line_num})"
							end
							@proc.puts "\t#{var}.appendChild(#{jsdom});"
						end
						if order
							i = order.to_i
							if @args.include?(i)
								raise "Error: argument #{i} is defined twice"
							end
							@args.add(i)
							@proc.puts "\tif(#{i}<arguments.length){"
							@proc.puts "\t\t#{graft}.#{name}=arguments[#{i}];"
							@proc.puts "\t}"
						end
					elsif child.name == "bond"
						name = child.attributes["name"]
						if @names.include?(name)
							raise "Error: #{name} is defined twice"
						end
						@names.add(name)
						@proc.puts "\tObject.defineProperty(#{graft},'#{name}',{"
						@proc.puts "\t\tget:function(){return #{var};}"
						@proc.puts "\t});"
					elsif child.name == "property"
						term(graft, var, child, "#{child.attributes["target"]}") {|v|
							"#{child.attributes["target"]}=#{v}"
						}
					elsif child.name == "attribute"
						term(graft, var, child, "getAttribute('#{child.attributes["target"]}')") {|v|
							"setAttribute('#{child.attributes["target"]}',#{v})"
						}
					else
						raise "Error: unknown stasc tag at #{node.line_num}"
					end
				else
					jsdom = walk(graft, child)
					if jsdom
						if $empty_tags.include?(node.name.downcase)
							puts "Warning: #{node.name} should be empty (line #{node.line_num})"
						end
						@proc.puts "\t#{var}.appendChild(#{jsdom});"
					end
				end
			end
			return var
		end
		return nil
	end

	def initialize(root)
		@last_var = 0
		@names = Set.new
		@args = Set.new
		@proc = StringIO.new()
		@var = walk(nil, root)
		if not (@args.sort == Array(0...@args.size))
			raise "Unused argument(s)"
		end
	end

	def var()
		return @var
	end

	def proc()
		return @proc.string
	end
end

begin
	opt = OptionParser.new
	Version = 1.5

	$a = "Stasc-a.js" if File.exists?("Stasc-a.js") # default value
	opt.on("-a file", "--after file") do |v|
		$a = v
	end

	$b = "Stasc-b.js" if File.exists?("Stasc-b.js") # default value
	opt.on("-b file", "--before file") do |v|
		$b = v
	end

	$notice = "generated by stasc #{Version}" # default value
	opt.on("-n file", "--notice file") do |v|
		$stderr.puts "Warning: -n is deplicated"
		File.open(v) do |file|
			$notice = file.read
		end
	end

	$output = "Stasc.js" # default value
	opt.on("-o file", "--output file") do |v|
		$output = v
	end

	$prefix = "" # default value
	opt.on("-p prefix", "--prefix prefix") do |v|
		$prefix = v
	end

	opt.parse!(ARGV)

	buf = StringIO.new
	buf.puts "/* #{$notice} */" if 0 < $notice.length
	if $a
		File.open($a) do |file|
			buf.puts file.read
		end
	end
	(ARGV.empty? ? Dir.glob("*.ss.xml").sort : ARGV).each do |src|
		dir = File.dirname(src)
		sym = File.basename(src, ".ss.xml")
		doc = XML::Document.file(src)
		buf.puts "#{$prefix}#{sym}=function(){"
		walker = Walker.new(doc.root)
		buf.puts walker.proc
		buf.puts "\treturn #{walker.var};"
		buf.puts "};"
	end
	if $b
		File.open($b) do |file|
			buf.puts file.read
		end
	end
	File.open($output, "w:utf-8") do |js|
		js.puts buf.string
	end
rescue Exception => exception
	$stderr.puts exception
	exit 1
end

