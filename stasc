#!/usr/bin/ruby
require "optparse"
require "stringio"
require "xml/libxml"
require "set"

XML.default_line_numbers=true

# tags to be empty
$empty_tags = [
	"area",
	"base",
	"basefont",
	"br",
	"col",
	"hr",
	"img",
	"input",
	"isindex",
	"link",
	"meta",
	"param",
]

$ns = "http://tshibata.github.io/2013/stasc"

class Walker
	def term(graft, var, child, getter) # for attribute and property
		name = child.attributes["name"]
		order = child.attributes["order"]
		children = child.children.delete_if{|node| (node.text? and node.content.strip.length == 0)}
		if name
			if children.size != 0
				raise "Error: named (monolithic) #{child.name} must be empty"
			end
			if @map.include?(name)
				raise "Error: #{name} is defined twice"
			end
			@map[name] = "" #FIXME
			@proc.puts "\tObject.defineProperty(#{graft}, '#{name}',{"
			@proc.puts "\t\tset:function(v){#{var}.#{yield 'v'};},"
			@proc.puts "\t\tget:function(){return #{var}.#{getter};}"
			@proc.puts "\t});"
			if order
				i = order.to_i
				if @args.include?(i)
					raise "Error: argument #{i} is defined twice"
				end
				@args.add(i)
				@proc.puts "\tif(#{i}<arguments.length){"
				@proc.puts "\t\t#{graft}.#{name}=arguments[#{i}];"
				@proc.puts "\t}"
			end
		else
			if order
				raise "Error: no order of nameless (composite) #{child.name}"
			end
			if children.size != 1
				raise "Error: #{child.name} can contain only one format"
			end
			if children[0].namespaces.namespace.href != $ns or children[0].name != "format"
				raise "Error: #{child.name} can contain only one format"
			end
			format = children[0]
			list = [XML::Node.new_text("")]
			format.each do |node|
				if node.text? and list[-1].text?
					list[-1] = XML::Node.new_text("#{list[-1].content}#{node.content}")
				else
					list.push(node)
				end
			end
			composition = list.map{|node|
				if node.text?
					"'#{node.content}'"
				elsif node.namespaces.namespace.href == $ns and node.name == "item"
					"m#{node.attributes['name']}"
				else
					raise "Error: format can contain only texts and items"
				end
			}.join("+")
			format.each_element do |item|
				name = item.attributes["name"]
				order = item.attributes["order"]
				if (item.children.size == 1 and not item.children[0].text?) or 1 < item.children.size
					raise "Error: item can contain only text"
				end
				@proc.puts "\tvar m#{name}='#{item.content}';"
				if order
					i = order.to_i
					if @args.include?(i)
						raise "Error: argument #{i} is defined twice"
					end
					@args.add(i)
					@proc.puts "\tif(#{i}<arguments.length){"
					@proc.puts "\t\tm#{name}=arguments[#{i}];"
					@proc.puts "\t}"
				end
				@map[name] = "" #FIXME
				@proc.puts "\tObject.defineProperty(#{graft}, '#{name}',{"
				@proc.puts "\t\tset:function(v){m#{name}=v;#{var}.#{yield composition};},"
				@proc.puts "\t\tget:function(){return m#{name};}"
				@proc.puts "\t});"
			end
			@proc.puts "\t#{var}.#{yield composition};"
		end
	end

	def walk(graft, node)
		case node.node_type
		when LibXML::XML::Node::TEXT_NODE
			text = node.content.strip
			text.gsub!(/\s+/," ");
			if text.empty? # FIXME: option
				return nil
			else
				return "document.createTextNode('#{text}')"
			end
		when LibXML::XML::Node::ELEMENT_NODE
			var = "n#{@last_var}"
			@last_var = @last_var + 1
			if not graft
				graft = var;
			end
			nodeNS = node.namespaces.namespace
			if nodeNS
				@proc.puts "\tvar #{var}=document.createElementNS('#{nodeNS.href}','#{node.name}');"
			else
				@proc.puts "\tvar #{var}=document.createElement('#{node.name}');"
			end
			node.attributes.each do |attribute|
				attrNS = attribute.namespaces.namespace
				if attrNS
					@proc.puts "\t#{var}.setAttributeNS('#{attrNS.href}','#{attribute.name}','#{attribute.value}');"
				else
					@proc.puts "\t#{var}.setAttribute('#{attribute.name}','#{attribute.value}');"
				end
			end
			node.each do |child|
				if not (child.cdata? || child.comment?)
					childNS = child.namespaces.namespace
					if childNS && childNS.href == $ns
						if child.name == "plug"
							jsdom = nil
							child.each_element do |element|
								if jsdom != nil
									raise "Error: more than one element in a plug at #{node.line_num}"
								end
								jsdom = walk(nil, element)
							end
							name = child.attributes["name"]
							order = child.attributes["order"]
							if @map.include?(name)
								raise "Error: #{name} is defined twice"
							end
							@map[name] = "" # FIXME
							@proc.puts "\tObject.defineProperty(#{graft},'#{name}',{"
							@proc.puts "\t\tset:function(v){#{var}.replaceChild(v,#{jsdom});#{jsdom}=v;},"
							@proc.puts "\t\tget:function(){return #{jsdom};}"
							@proc.puts "\t});"
							if jsdom
								if $empty_tags.include?(node.name.downcase)
									puts "Warning: #{node.name} should be empty (line #{node.line_num})"
								end
								@proc.puts "\t#{var}.appendChild(#{jsdom});"
							end
							if order
								i = order.to_i
								if @args.include?(i)
									raise "Error: argument #{i} is defined twice"
								end
								@args.add(i)
								@proc.puts "\tif(#{i}<arguments.length){"
								@proc.puts "\t\t#{graft}.#{name}=arguments[#{i}];"
								@proc.puts "\t}"
							end
						elsif child.name == "bond"
							name = child.attributes["name"]
							if @map.include?(name)
								raise "Error: #{name} is defined twice"
							end
							@map[name] = "" # FIXME
							@proc.puts "\tObject.defineProperty(#{graft},'#{name}',{"
							@proc.puts "\t\tget:function(){return #{var};}"
							@proc.puts "\t});"
						elsif child.name == "property"
							term(graft, var, child, "#{child.attributes["target"]}") {|v|
								"#{child.attributes["target"]}=#{v}"
							}
						elsif child.name == "attribute"
							term(graft, var, child, "getAttribute('#{child.attributes["target"]}')") {|v|
								"setAttribute('#{child.attributes["target"]}',#{v})"
							}
						else
							raise "Error: unknown stasc tag at #{node.line_num}"
						end
					else
						jsdom = walk(graft, child)
						if jsdom
							if $empty_tags.include?(node.name.downcase)
								puts "Warning: #{node.name} should be empty (line #{node.line_num})"
							end
							@proc.puts "\t#{var}.appendChild(#{jsdom});"
						end
					end
				end
			end
			return var
		end
		return nil
	end
	def initialize(root)
		@last_var = 0
		@map = {}
		@args = Set.new
		@proc = StringIO.new()
		@var = walk(nil, root)
		if not (@args.sort == Array(0...@args.size))
			raise "Unused argument(s)"
		end
	end
	def var()
		return @var
	end
	def proc()
		return @proc.string
	end
end

opt = OptionParser.new
Version = 1.5

$a = "Stasc-a.js" if File.exists?("Stasc-a.js") # default value
opt.on("-a file", "--after file") do |v|
	$a = v
end

$b = "Stasc-b.js" if File.exists?("Stasc-b.js") # default value
opt.on("-b file", "--before file") do |v|
	$b = v
end

$notice = "generated by stasc #{Version}" # default value
opt.on("-n file", "--notice file") do |v|
	$stderr.puts "Warning: -n is deplicated"
	File.open(v) do |file|
		$notice = file.read
	end
end

$output = "Stasc.js" # default value
opt.on("-o file", "--output file") do |v|
	$output = v
end

$prefix = "" # default value
opt.on("-p prefix", "--prefix prefix") do |v|
	$prefix = v
end

opt.parse!(ARGV)

buf = StringIO.new
buf.puts "/* #{$notice} */" if 0 < $notice.length
if $a
	File.open($a) do |file|
		buf.puts file.read
	end
end
(ARGV.empty? ? Dir.glob("*.ss.xml").sort : ARGV).each do |src|
	dir = File.dirname(src)
	sym = File.basename(src, ".ss.xml")
	doc = XML::Document.file(src)
	buf.puts "#{$prefix}#{sym}=function(){"
	walker = Walker.new(doc.root)
	buf.puts walker.proc
	buf.puts "\treturn #{walker.var};"
	buf.puts "};"
end
if $b
	File.open($b) do |file|
		buf.puts file.read
	end
end
File.open($output, "w:utf-8") do |js|
	js.puts buf.string
end

