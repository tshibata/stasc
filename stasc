#!/usr/bin/ruby
require "optparse"
require "stringio"
require "xml/libxml"
require "set"

XML.default_line_numbers=true
XML::Error.reset_handler

# tags to be empty
$empty_tags = [
	"area",
	"base",
	"basefont",
	"br",
	"col",
	"hr",
	"img",
	"input",
	"isindex",
	"link",
	"meta",
	"param",
]

$ns = "http://tshibata.github.io/2013/stasc"

class AttributeAccessor
	def initialize(var, node)
		@var = var
		@node = node
	end
	def dataSetter(value)
		target = @node.attributes["target"]
		if /([^:]*):(.*)/ =~ target
			ns = @node.namespaces.find_by_prefix($1)
			name = $2
			return "#{@var}.setAttributeNS('#{ns.href}','#{name}',#{value})"
		else
			return "#{@var}.setAttribute('#{target}',#{value})"
		end
	end
	def dataGetter()
		target = @node.attributes["target"]
		if /([^:]*):(.*)/ =~ target
			ns = @node.namespaces.find_by_prefix($1)
			name = $2
			return "#{@var}.getAttributeNS('#{ns.href}','#{name}')"
		else
			return "#{@var}.getAttribute('#{target}')"
		end
	end
end

class PropertyAccessor
	def initialize(var, node)
		@var = var
		@node = node
	end
	def dataSetter(value)
		target = @node.attributes["target"]
		return "#{@var}.#{target}=#{value}"
	end
	def dataGetter()
		target = @node.attributes["target"]
		return "#{@var}.#{target}"
	end
end

class Item

	def initialize(name, order, text)
		@name = name
		@order = order
		@text = text
	end

	def append(text)
		return false
	end

	def getValue()
		return "m#{@name}"
	end

	def output(args, names, proc, graft, accessor, composition)
		proc.puts "\tvar m#{@name}='#{@text}';"
		if @order
			i = @order.to_i
			if args.include?(i)
				raise "Error: argument #{i} is defined twice"
			end
			args.add(i)
			proc.puts "\tif(#{i}<arguments.length){"
			proc.puts "\t\tm#{@name}=arguments[#{i}];"
			proc.puts "\t}"
		end
		names.add(@name)
		proc.puts "\tObject.defineProperty(#{graft}, '#{@name}',{"
		proc.puts "\t\tset:function(v){m#{@name}=v;#{accessor.dataSetter(composition)};},"
		proc.puts "\t\tget:function(){return m#{@name};}"
		proc.puts "\t});"
	end
end

class StaticItem

	def initialize(text)
		@text = text
	end

	def append(text)
		@text = @text + text
		return true
	end

	def getValue()
		text = @text;
		text.gsub!(/\\/) {"\\\\"};
		text.gsub!(/'/) {"\\'"};
		return "'#{text}'"
	end

	def output(args, names, proc, graft, accessor, composition)
	end
end

class Format

	def initialize(node)
		@items = [StaticItem.new("")]
		node.each do |n|
			if n.text?
				if not @items[-1].append(n.content)
					@items.push(StaticItem.new(n.content))
				end
			elsif n.namespaces.namespace.href == $ns and n.name == "item"
				if n.children.size != 1
					raise "Error: item can contain only text"
				end
				if not n.children[0].text?
					raise "Error: item can contain only text"
				end
				@items.push(Item.new(n.attributes["name"], n.attributes["order"], n.content))
			else
				raise "Error: format can contain only texts and items"
			end
		end
		@composition = @items.map{|item| item.getValue()}.join("+")
	end

	def output(args, names, proc, graft, accessor)
		@items.each do |item|
			item.output(args, names, proc, graft, accessor, @composition)
		end
		proc.puts "\t#{accessor.dataSetter(@composition)};"
	end
end

class NamedValue

	def initialize(node, accessor)
		@name = node.attributes["name"]
		@order = node.attributes["order"]
		@children = node.children.delete_if{|n| (n.text? and n.content.strip.length == 0)}
		@accessor = accessor
	end

	def output(args, names, proc, graft)
		if @name
			if @children.size != 0
				raise "Error: named (monolithic) #{node.name} must be empty"
			end
			if names.include?(@name)
				raise "Error: #{name} is defined twice"
			end
			names.add(@name)
			proc.puts "\tObject.defineProperty(#{graft}, '#{@name}',{"
			proc.puts "\t\tset:function(v){#{@accessor.dataSetter('v')};},"
			proc.puts "\t\tget:function(){return #{@accessor.dataGetter()};}"
			proc.puts "\t});"
			if @order
				i = @order.to_i
				if args.include?(i)
					raise "Error: argument #{i} is defined twice"
				end
				args.add(i)
				proc.puts "\tif(#{i}<arguments.length){"
				proc.puts "\t\t#{graft}.#{@name}=arguments[#{i}];"
				proc.puts "\t}"
			end
		else
			if @order
				raise "Error: no order of nameless (composite) #{node.name}"
			end
			if @children.size != 1
				raise "Error: #{node.name} can contain only one format"
			end
			if @children[0].namespaces.namespace.href != $ns or @children[0].name != "format"
				raise "Error: #{node.name} can contain only one format"
			end
			format = Format.new(@children[0])
			format.output(args, names, proc, graft, @accessor)
		end
	end
end

class Attribute < NamedValue
	def initialize(var, node)
		super(node, AttributeAccessor.new(var, node))
	end
end

class Property < NamedValue
	def initialize(var, node)
		super(node, PropertyAccessor.new(var, node))
	end
end

class Bond

	def initialize(var, node)
		@var = var
		@name = node.attributes["name"]
	end

	def output(names, proc, graft)
		if names.include?(@name)
			raise "Error: #{@name} is defined twice"
		end
		names.add(@name)
		proc.puts "\tObject.defineProperty(#{graft},'#{@name}',{"
		proc.puts "\t\tget:function(){return #{@var};}"
		proc.puts "\t});"
	end
end

class Plug

	def initialize(var, parent, node)
		@var = var
		@parent = parent
		@node = node
	end

	def output(walker, args, names, proc, graft)
		if $empty_tags.include?(@parent.name.downcase)
			puts "Warning: #{@parent.name} should be empty (line #{@parent.line_num})"
		end
		children = @node.children.delete_if{|n| (n.text? and n.content.strip.length == 0)}
		if children.size == 0
			raise "Error: no element in a plug at #{@node.line_num}"
		elsif 1 < children.size
			raise "Error: more than one element in a plug at #{@node.line_num}"
		end
		jsdom = walker.walk(nil, children[0]) # FIXME what about text node?
		name = @node.attributes["name"]
		order = @node.attributes["order"]
		if names.include?(name)
			raise "Error: #{name} is defined twice"
		end
		names.add(name)
		proc.puts "\tObject.defineProperty(#{graft},'#{name}',{"
		proc.puts "\t\tset:function(v){#{@var}.replaceChild(v,#{jsdom});#{jsdom}=v;},"
		proc.puts "\t\tget:function(){return #{jsdom};}"
		proc.puts "\t});"
		proc.puts "\t#{@var}.appendChild(#{jsdom});"
		if order
			i = order.to_i
			if args.include?(i)
				raise "Error: argument #{i} is defined twice"
			end
			args.add(i)
			proc.puts "\tif(#{i}<arguments.length){"
			proc.puts "\t\t#{graft}.#{name}=arguments[#{i}];"
			proc.puts "\t}"
		end
	end
end

class Text

	def initialize(node)
		@text = node.content.strip
		@text.gsub!(/\s+/," ");
		@text.gsub!(/\\/) {"\\\\"};
		@text.gsub!(/'/) {"\\'"};
	end

	def output(var, proc)
		if not @text.empty? # FIXME: option
			proc.puts "\t#{var}.appendChild(document.createTextNode('#{@text}'));"
		end
	end
end

class Walker

	def walk(graft, node)
		var = "n#{@last_var}"
		@last_var = @last_var + 1
		if not graft
			graft = var;
		end
		nodeNS = node.namespaces.namespace
		if nodeNS
			@proc.puts "\tvar #{var}=document.createElementNS('#{nodeNS.href}','#{node.name}');"
		else
			@proc.puts "\tvar #{var}=document.createElement('#{node.name}');"
		end
		node.attributes.each do |attribute|
			attrNS = attribute.namespaces.namespace
			if attrNS
				@proc.puts "\t#{var}.setAttributeNS('#{attrNS.href}','#{attribute.name}','#{attribute.value}');"
			else
				@proc.puts "\t#{var}.setAttribute('#{attribute.name}','#{attribute.value}');"
			end
		end
		node.each do |child|
			childNS = child.namespaces.namespace
			if childNS && childNS.href == $ns
				if child.name == "plug"
					plug = Plug.new(var, node, child)
					plug.output(self, @args, @names, @proc, graft)
				elsif child.name == "bond"
					bond = Bond.new(var, child)
					bond.output(@names, @proc, graft)
				elsif child.name == "attribute"
					attribute = Attribute.new(var, child)
					attribute.output(@args, @names, @proc, graft)
				elsif child.name == "property" 
					property = Property.new(var, child)
					property.output(@args, @names, @proc, graft)
				else
					raise "Error: unknown stasc tag at #{child.line_num}"
				end
			elsif child.node_type == LibXML::XML::Node::TEXT_NODE
				text = Text.new(child)
				text.output(var, @proc)
			elsif child.node_type == LibXML::XML::Node::ELEMENT_NODE
				if $empty_tags.include?(node.name.downcase)
					puts "Warning: #{node.name} should be empty (line #{node.line_num})"
				end
				@proc.puts "\t#{var}.appendChild(#{walk(graft, child)});"
			end
		end
		return var
	end

	def initialize(root)
		@last_var = 0
		@names = Set.new
		@args = Set.new
		@proc = StringIO.new()
		@var = walk(nil, root)
		if not (@args.sort == Array(0...@args.size))
			raise "Unused argument(s)"
		end
	end

	def var()
		return @var
	end

	def proc()
		return @proc.string
	end
end

begin
	opt = OptionParser.new
	Version = 1.5

	$a = "Stasc-a.js" if File.exists?("Stasc-a.js") # default value
	opt.on("-a file", "--after file") do |v|
		$a = v
	end

	$b = "Stasc-b.js" if File.exists?("Stasc-b.js") # default value
	opt.on("-b file", "--before file") do |v|
		$b = v
	end

	$notice = "generated by stasc #{Version}" # default value
	opt.on("-n file", "--notice file") do |v|
		$stderr.puts "Warning: -n is deplicated"
		File.open(v) do |file|
			$notice = file.read
		end
	end

	$output = "Stasc.js" # default value
	opt.on("-o file", "--output file") do |v|
		$output = v
	end

	$prefix = "" # default value
	opt.on("-p prefix", "--prefix prefix") do |v|
		$prefix = v
	end

	opt.parse!(ARGV)

	buf = StringIO.new
	buf.puts "/* #{$notice} */" if 0 < $notice.length
	if $a
		File.open($a) do |file|
			buf.puts file.read
		end
	end
	(ARGV.empty? ? Dir.glob("*.ss.xml").sort : ARGV).each do |src|
		begin
			dir = File.dirname(src)
			sym = File.basename(src, ".ss.xml")
			doc = XML::Document.file(src)
			buf.puts "#{$prefix}#{sym}=function(){"
			walker = Walker.new(doc.root)
			buf.puts walker.proc
			buf.puts "\treturn #{walker.var};"
			buf.puts "};"
		rescue Exception => exception
			raise "#{exception} in #{src}"
		end
	end
	if $b
		File.open($b) do |file|
			buf.puts file.read
		end
	end
	File.open($output, "w:utf-8") do |js|
		js.puts buf.string
	end
rescue Exception => exception
	$stderr.puts exception
	exit 1
end

